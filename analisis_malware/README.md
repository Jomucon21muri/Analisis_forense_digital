# Análisis forense de malware: metodología avanzada

## 1. Marco teórico y taxonomía del malware

### 1.1 Clasificación según taxonomía IEEE

El análisis de malware sigue la taxonomía establecida por el **IEEE Computer Society** y refinada por investigadores como Szor (2005) y Sikorski & Honig (2012):

#### Taxonomía por Mecanismo de Propagación
- **Virus**: Código parasitario que requiere host (infección de archivos)
- **Gusanos**: Autorreplicación autónoma a través de redes
- **Troyanos**: Funcionalidad maliciosa oculta en software aparentemente legítimo
- **Rootkits**: Ocultación de presencia mediante hooks en kernel/userland
- **Bootkits**: Infección de MBR/GPT/UEFI para persistencia pre-OS

#### Taxonomía por Objetivo
- **Ransomware**: Cifrado de datos con extorsión económica (CryptoLocker, WannaCry, REvil)
- **Spyware/Infostealer**: Exfiltración de credenciales, datos bancarios, PII
- **Backdoors/RATs**: Acceso remoto persistente (Cobalt Strike, Metasploit, njRAT)
- **Botnets**: Redes de sistemas comprometidos (Mirai, Emotet, TrickBot)
- **Wipers**: Destrucción deliberada de datos (NotPetya, WhisperGate)
- **APT Toolkits**: Frameworks sofisticados de actores estatales

#### Taxonomía por Técnica de Evasión
- **Polimorfismo**: Cambio de firma manteniendo funcionalidad
- **Metamorfismo**: Reescritura completa del código en cada iteración
- **Packing/Crypting**: Ofuscación mediante compresión y cifrado (UPX, Themida, VMProtect)
- **Steganografía**: Ocultación en imágenes, documentos o protocolos
- **Fileless Malware**: Ejecución en memoria sin tocar disco (PowerShell Empire, Cobalt Strike)

### 1.2 Modelo de análisis: diamond model & MITRE ATT&CK

El análisis forense de malware se estructura según:
- **Diamond Model**: Adversary, Infrastructure, Capability, Victim (Caltagirone et al., 2013)
- **Cyber Kill Chain**: Reconocimiento → Armado → Entrega → Explotación → Instalación → C2 → Acciones
- **MITRE ATT&CK**: Framework de TTPs organizados en tácticas y técnicas

---

## 2. Preparación del laboratorio forense

### 2.1 Arquitectura de aislamiento

```bash
# === NUNCA ejecutar malware en sistema de producción ===

# Opción 1: VM con snapshots (VirtualBox/VMware)
# - Red en modo Host-Only o Internal Network
# - Deshabilitar carpetas compartidas y drag-and-drop
# - Snapshot limpio antes de cada análisis

# Opción 2: Contenedor Docker aislado
docker run -it --rm --network none \
  --cap-drop=ALL --security-opt=no-new-privileges \
  -v /samples:/malware:ro \
  remnux/remnux-distro:focal bash

# Opción 3: VM dedicada con REMnux
# Descargar: https://remnux.org/
# O FLARE-VM para análisis Windows: https://github.com/mandiant/flare-vm
```

### 2.2 Configuración de entorno controlado

```bash
# Instalar herramientas en Ubuntu/Debian
apt update && apt install -y \
  binutils hexedit ltrace strace \
  radare2 rizin cutter iaito \
  python3-pefile python3-yara yara \
  upx-ucl file libmagic-dev \
  volatility3 clamav ssdeep \
  ghidra ghidra-data \
  wireshark tcpdump tshark \
  fakenet-ng inetsim \
  maltrail suricata

# Configurar INetSim (simulador de servicios)
cat > /etc/inetsim/inetsim.conf <<EOF
dns_default_ip      10.0.2.15
https_bind_address  0.0.0.0
service dns
service http
service https
service smtp
service ftp
EOF
systemctl start inetsim

# Configurar FakeNet-NG (Windows alternative)
# Descarga: https://github.com/mandiant/flare-fakenet-ng
fakenet.exe -c fakenet.conf

# Variables de entorno
export MALWARE_SAMPLE="/samples/suspicious.exe"
export CASE_ID="MAL-2026-001"
export REPORT_DIR="/reports/${CASE_ID}"
mkdir -p "${REPORT_DIR}"/{static,dynamic,network,memory}
```

---

## 3. Análisis estático: fase de reconocimiento

### 3.1 Identificación inicial y hashing

```bash
# Calcular hashes criptográficos
md5sum "${MALWARE_SAMPLE}" > "${REPORT_DIR}/hashes.txt"
sha1sum "${MALWARE_SAMPLE}" >> "${REPORT_DIR}/hashes.txt"
sha256sum "${MALWARE_SAMPLE}" >> "${REPORT_DIR}/hashes.txt"
ssdeep "${MALWARE_SAMPLE}" >> "${REPORT_DIR}/hashes.txt"

# Identificar tipo de archivo
file -b "${MALWARE_SAMPLE}"
exiftool "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/metadata.txt"

# Detectar packing/ofuscación
detect-it-easy "${MALWARE_SAMPLE}" --json > "${REPORT_DIR}/static/die_analysis.json"

# Entropy analysis (alta entropía = probablemente packed/encrypted)
python3 <<EOF
import math
from collections import Counter

def calculate_entropy(data):
    if not data:
        return 0
    entropy = 0
    for count in Counter(data).values():
        p_x = count / len(data)
        entropy -= p_x * math.log2(p_x)
    return entropy

with open("${MALWARE_SAMPLE}", 'rb') as f:
    data = f.read()
    entropy = calculate_entropy(data)
    print(f"Shannon Entropy: {entropy:.4f} bits/byte")
    print("High entropy (>7.0) suggests packing/encryption" if entropy > 7.0 else "Normal entropy")
EOF
```

### 3.2 Análisis de strings

```bash
# Extraer strings ASCII y Unicode
strings -a -n 8 "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/strings_ascii.txt"
strings -a -e l -n 8 "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/strings_unicode.txt"

# Buscar IOCs en strings
grep -iE "(http|https|ftp)://[a-zA-Z0-9./?=_-]*" "${REPORT_DIR}/static/strings_ascii.txt" \
  > "${REPORT_DIR}/static/urls.txt"

grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" "${REPORT_DIR}/static/strings_ascii.txt" \
  > "${REPORT_DIR}/static/ips.txt"

grep -iE "[a-z0-9]+@[a-z0-9]+\.[a-z]+" "${REPORT_DIR}/static/strings_ascii.txt" \
  > "${REPORT_DIR}/static/emails.txt"

# Buscar APIs sospechosas
grep -iE "(VirtualAlloc|CreateRemoteThread|WriteProcessMemory|CreateProcess|URLDownloadToFile|WinExec|ShellExecute)" \
  "${REPORT_DIR}/static/strings_ascii.txt" > "${REPORT_DIR}/static/suspicious_apis.txt"

# FLOSS (FLARE Obfuscated String Solver) para strings ofuscados
floss "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/floss_output.txt"
```

### 3.3 Análisis de formato PE (Portable Executable - Windows)

```bash
# pefile (Python)
python3 <<EOF
import pefile
import json

pe = pefile.PE("${MALWARE_SAMPLE}")

analysis = {
    "machine": hex(pe.FILE_HEADER.Machine),
    "timestamp": pe.FILE_HEADER.TimeDateStamp,
    "sections": [],
    "imports": {},
    "exports": []
}

# Secciones
for section in pe.sections:
    analysis["sections"].append({
        "name": section.Name.decode().rstrip('\x00'),
        "virtual_address": hex(section.VirtualAddress),
        "virtual_size": section.Misc_VirtualSize,
        "raw_size": section.SizeOfRawData,
        "entropy": section.get_entropy()
    })

# Import Address Table
if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll = entry.dll.decode()
        analysis["imports"][dll] = []
        for imp in entry.imports:
            if imp.name:
                analysis["imports"][dll].append(imp.name.decode())

# Export Table
if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
        if exp.name:
            analysis["exports"].append(exp.name.decode())

with open("${REPORT_DIR}/static/pe_analysis.json", 'w') as f:
    json.dump(analysis, f, indent=2)

print(json.dumps(analysis, indent=2))
EOF

# pestudio (Windows alternative)
# https://www.winitor.com/pestudio

# Verificar firma digital
osslsigncode verify "${MALWARE_SAMPLE}" 2>&1 | tee "${REPORT_DIR}/static/signature.txt"

# Analizar recursos embebidos
wrestool -x -l "${MALWARE_SAMPLE}" --output="${REPORT_DIR}/static/resources/"
```

### 3.4 Análisis de formato ELF (Linux)

```bash
# Headers y secciones
readelf -h "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/elf_header.txt"
readelf -l "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/elf_program_headers.txt"
readelf -S "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/elf_sections.txt"

# Símbolos y funciones
nm -D "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/dynamic_symbols.txt"
readelf -s "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/symbol_table.txt"

# Dependencias compartidas
ldd "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/dependencies.txt" 2>&1
readelf -d "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/dynamic_section.txt"
```

### 3.5 Detección con YARA

```bash
# Crear reglas YARA personalizadas
cat > /tmp/malware_rules.yar <<'EOF'
rule Suspicious_API_Calls
{
    meta:
        description = "Detects common malicious API patterns"
        author = "Forensic Lab"
        date = "2026-01-30"
    
    strings:
        $api1 = "VirtualAllocEx" ascii
        $api2 = "WriteProcessMemory" ascii
        $api3 = "CreateRemoteThread" ascii
        $api4 = "LoadLibrary" ascii
        $api5 = "GetProcAddress" ascii
        
    condition:
        3 of ($api*)
}

rule Ransomware_Extensions
{
    strings:
        $ext1 = ".encrypted" ascii
        $ext2 = ".locked" ascii
        $ext3 = ".crypt" ascii
        $msg = "YOUR FILES HAVE BEEN ENCRYPTED" ascii nocase
        
    condition:
        any of them
}

rule CobaltStrike_Beacon
{
    meta:
        description = "Detects Cobalt Strike beacon"
        reference = "https://github.com/Neo23x0/signature-base"
        
    strings:
        $s1 = "%c%c%c%c%c%c%c%c%cMSSE-%d-server" ascii
        $s2 = "beacon.dll" ascii
        
    condition:
        any of them
}
EOF

# Escanear con YARA
yara -w -s /tmp/malware_rules.yar "${MALWARE_SAMPLE}" > "${REPORT_DIR}/static/yara_matches.txt"

# Usar reglas públicas
git clone https://github.com/Yara-Rules/rules.git /opt/yara-rules
yara -r /opt/yara-rules/ "${MALWARE_SAMPLE}"
```

### 3.6 Consulta a threat intelligence

```bash
# VirusTotal lookup
VT_API_KEY="your_api_key"
HASH=$(sha256sum "${MALWARE_SAMPLE}" | cut -d' ' -f1)

curl -s --request GET \
  --url "https://www.virustotal.com/api/v3/files/${HASH}" \
  --header "x-apikey: ${VT_API_KEY}" | \
  jq '.' > "${REPORT_DIR}/static/virustotal_report.json"

# Hybrid Analysis lookup
curl -s "https://www.hybrid-analysis.com/api/v2/search/hash" \
  -H "api-key: YOUR_KEY" \
  -H "user-agent: Falcon Sandbox" \
  -d "hash=${HASH}" > "${REPORT_DIR}/static/hybrid_analysis.json"

# MalwareBazaar
curl -s -X POST "https://mb-api.abuse.ch/api/v1/" \
  --data "query=get_info&hash=${HASH}" | \
  jq '.' > "${REPORT_DIR}/static/malwarebazaar.json"

# AlienVault OTX
curl -s "https://otx.alienvault.com/api/v1/indicators/file/${HASH}/general" \
  -H "X-OTX-API-KEY: YOUR_KEY" > "${REPORT_DIR}/static/otx_report.json"
```

---

## 4. Análisis dinámico: ejecución controlada

### 4.1 Preparación del entorno de sandbox

```bash
# Crear snapshot limpio de VM
VBoxManage snapshot "Windows10_Lab" take "clean_state"

# Configurar monitorización ANTES de ejecutar
# - Process Monitor (Procmon)
# - Process Hacker
# - Regshot (before/after registry)
# - Wireshark en interfaz de red

# En Windows:
# 1. Ejecutar Procmon con filtros (Excluir procesos del sistema)
# 2. Ejecutar Regshot → 1st Shot
# 3. Capturar red: Wireshark
```

### 4.2 Tracing con strace/ltrace (Linux)

```bash
# System call tracing
strace -f -o "${REPORT_DIR}/dynamic/strace.log" \
  -e trace=open,openat,read,write,connect,socket,execve,clone \
  "${MALWARE_SAMPLE}"

# Library call tracing
ltrace -f -o "${REPORT_DIR}/dynamic/ltrace.log" \
  -e '*' \
  "${MALWARE_SAMPLE}"

# Captura de red simultánea
tcpdump -i any -w "${REPORT_DIR}/network/capture.pcap" &
TCPDUMP_PID=$!

# Ejecutar malware con timeout
timeout 300s "${MALWARE_SAMPLE}" || true

kill $TCPDUMP_PID
```

### 4.3 Análisis con Cuckoo Sandbox

```bash
# Instalación de Cuckoo (simplificada)
pip3 install cuckoo

# Inicializar
cuckoo init
cuckoo community

# Configurar máquina virtual
cuckoo machine --add windows10_lab --platform windows \
  --ip 192.168.56.101 --snapshot clean_state

# Enviar muestra
cuckoo submit "${MALWARE_SAMPLE}" --timeout 300 --enforce-timeout

# Obtener reporte
cuckoo web  # Acceder a http://localhost:8000
# O exportar JSON
cuckoo report --json <task_id> > "${REPORT_DIR}/dynamic/cuckoo_report.json"
```

### 4.4 Análisis de comportamiento en Windows

```powershell
# === Ejecutar en Windows análisis VM ===

# Capturar estado inicial del sistema
Get-Process | Export-Csv C:\before_processes.csv
Get-Service | Export-Csv C:\before_services.csv
Get-ScheduledTask | Export-Csv C:\before_tasks.csv
Get-NetTCPConnection | Export-Csv C:\before_connections.csv

# Regshot: 1st shot
# GUI: Shot → 1st Shot

# Process Monitor: Iniciar captura con filtros
# - Process Name contains suspicious.exe
# - Exclude: System, Registry, svchost

# === EJECUTAR MALWARE ===
# (En entorno aislado)

# Esperar tiempo de observación (5-10 min)
Start-Sleep -Seconds 600

# Capturar estado final
Get-Process | Export-Csv C:\after_processes.csv
Get-Service | Export-Csv C:\after_services.csv
Get-ScheduledTask | Export-Csv C:\after_tasks.csv
Get-NetTCPConnection | Export-Csv C:\after_connections.csv

# Regshot: 2nd shot y Compare
# GUI: Shot → 2nd Shot → Compare

# Exportar procmon CSV
# File → Save → CSV

# Análisis de persistencia
reg export HKLM\Software\Microsoft\Windows\CurrentVersion\Run C:\persistence_hklm.reg
reg export HKCU\Software\Microsoft\Windows\CurrentVersion\Run C:\persistence_hkcu.reg

# Tareas programadas creadas
Get-ScheduledTask | Where-Object {$_.Date -gt (Get-Date).AddMinutes(-15)}

# Archivos dropped
Get-ChildItem C:\ -Recurse -File | Where-Object {$_.CreationTime -gt (Get-Date).AddMinutes(-15)} | 
  Select-Object FullName, CreationTime, Length | Export-Csv C:\dropped_files.csv
```

### 4.5 Análisis de tráfico de red

```bash
# Analizar PCAP capturado
tshark -r "${REPORT_DIR}/network/capture.pcap" -q -z io,phs

# Extraer URLs y dominios
tshark -r "${REPORT_DIR}/network/capture.pcap" -Y "http.request" \
  -T fields -e http.host -e http.request.uri | \
  sort -u > "${REPORT_DIR}/network/http_requests.txt"

# Extraer IP de destino
tshark -r "${REPORT_DIR}/network/capture.pcap" -T fields -e ip.dst | \
  sort -u | grep -v "^192\.168\." | grep -v "^10\." > \
  "${REPORT_DIR}/network/external_ips.txt"

# Análisis DNS
tshark -r "${REPORT_DIR}/network/capture.pcap" -Y "dns.qry.name" \
  -T fields -e dns.qry.name | sort -u > \
  "${REPORT_DIR}/network/dns_queries.txt"

# Extraer archivos transferidos (HTTP)
tshark -r "${REPORT_DIR}/network/capture.pcap" --export-objects http,"${REPORT_DIR}/network/http_objects"

# Detección con Suricata
suricata -c /etc/suricata/suricata.yaml \
  -r "${REPORT_DIR}/network/capture.pcap" \
  -l "${REPORT_DIR}/network/suricata_logs"

# Analizar alertas
cat "${REPORT_DIR}/network/suricata_logs/fast.log"
```

---

## 5. Ingeniería inversa: análisis profundo

### 5.1 Unpacking (desempaquetado)

```bash
# Detectar packer
detect-it-easy "${MALWARE_SAMPLE}"

# UPX unpacking
upx -d "${MALWARE_SAMPLE}" -o "${REPORT_DIR}/static/unpacked.exe"

# Para packers customizados, usar unpacking dinámico
# x64dbg (Windows) con plugin OllyDumpEx
# O automated unpacking con unipacker
pip3 install unipacker
unipacker "${MALWARE_SAMPLE}"

# Alternativa: memory dumping post-ejecución
# En el sandbox, una vez cargado:
procdump -ma <PID> unpacked_from_memory.dmp
```

### 5.2 Desensamblado con Ghidra

```bash
# Análisis automatizado con Ghidra Headless
analyzeHeadless /tmp/ghidra_projects "MalwareAnalysis" \
  -import "${MALWARE_SAMPLE}" \
  -postScript DecompileAllScript.java \
  -scriptPath /opt/ghidra/scripts

# Exportar pseudocódigo
# (Requiere script personalizado o uso de GUI)

# Alternativa: uso de GUI
# 1. File → Import File → seleccionar malware
# 2. Analysis → Auto Analyze
# 3. Window → Defined Strings
# 4. Search → For Instruction Patterns
# 5. Identificar main/WinMain/DllMain
```

### 5.3 Análisis con radare2/rizin

```bash
# Abrir binario
r2 -A "${MALWARE_SAMPLE}"

# Comandos básicos de r2
# aaa    - Analizar todo
# afl    - Listar funciones
# pdf @main - Desensamblar función main
# iz     - Listar strings en .rodata
# ii     - Listar imports
# ie     - Listar entrypoints

# Scripting con r2pipe
python3 <<'EOF'
import r2pipe
import json

r2 = r2pipe.open("${MALWARE_SAMPLE}")
r2.cmd("aaa")

# Funciones
functions = json.loads(r2.cmd("aflj"))
print(f"Total functions: {len(functions)}")

# Strings sospechosos
strings = r2.cmd("iz~cmd,exec,shell,download")
print(strings)

# Imports
imports = json.loads(r2.cmd("iij"))
for imp in imports:
    print(f"{imp['name']}")

r2.quit()
EOF
```

### 5.4 Emulación con Qiling/Unicorn

```python
#!/usr/bin/env python3
# Emular código específico sin ejecutar completamente

from qiling import Qiling
from qiling.const import QL_VERBOSE

def my_sandbox(path, rootfs):
    ql = Qiling(path=[path], rootfs=rootfs, verbose=QL_VERBOSE.DEBUG)
    
    # Hook funciones
    @ql.set_api('CreateFileW', QL_INTERCEPT.ENTER)
    def hook_CreateFile(ql, address, params):
        print(f"[API] CreateFileW: {params['lpFileName']}")
        return 0
    
    # Ejecutar
    ql.run()

my_sandbox("${MALWARE_SAMPLE}", "/path/to/fake/windows/rootfs")
```

---

## 6. Análisis de persistencia y técnicas avanzadas

### 6.1 Mecanismos de persistencia (Windows)

```powershell
# Registry Run Keys
Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"

# Tareas programadas
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"} | 
  Select-Object TaskName, TaskPath, State, Actions

# Servicios
Get-Service | Where-Object {$_.StartType -eq "Automatic"}
Get-WmiObject Win32_Service | Where-Object {$_.StartMode -eq "Auto"}

# WMI Event Subscriptions (fileless persistence)
Get-WMIObject -Namespace root\Subscription -Class __EventFilter
Get-WMIObject -Namespace root\Subscription -Class __EventConsumer
Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding

# Startup folder
Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"

# DLL Search Order Hijacking
# Buscar DLLs en carpetas de aplicaciones
```

### 6.2 Detección de rootkits

```bash
# Linux: chkrootkit y rkhunter
chkrootkit > "${REPORT_DIR}/dynamic/chkrootkit.log"
rkhunter --check --skip-keypress --report-warnings-only

# Windows: GMER, RootkitRevealer
# https://www.gmer.net/

# Volatility para análisis de memoria (detectar hooks)
volatility3 -f memory.dmp windows.ssdt.SSDT
volatility3 -f memory.dmp windows.callbacks.Callbacks
volatility3 -f memory.dmp windows.driverirp.DriverIrp
```

---

## 7. Generación de IOCs y correlación ATT&CK

### 7.1 Extracción de indicadores

```bash
# Generar STIX/MISP JSON
python3 <<'EOF'
import json
from datetime import datetime

iocs = {
    "type": "bundle",
    "id": "bundle--${CASE_ID}",
    "objects": [
        {
            "type": "malware",
            "id": "malware--${CASE_ID}",
            "name": "Suspicious Sample",
            "created": datetime.utcnow().isoformat() + "Z",
            "labels": ["trojan", "backdoor"]
        },
        {
            "type": "indicator",
            "id": "indicator--hash",
            "pattern": "[file:hashes.SHA256 = '${HASH}']",
            "valid_from": datetime.utcnow().isoformat() + "Z"
        }
        # Añadir más indicadores (IPs, dominios, etc.)
    ]
}

with open("${REPORT_DIR}/iocs_stix.json", 'w') as f:
    json.dump(iocs, f, indent=2)
EOF

# OpenIOC format
# Herramienta: IOC Editor (Mandiant)
```

### 7.2 Mapeo a MITRE ATT&CK

```python
#!/usr/bin/env python3
# Mapear comportamientos observados a ATT&CK

attack_mapping = {
    "T1059.001": "PowerShell execution detected",
    "T1055": "Process Injection via CreateRemoteThread",
    "T1547.001": "Registry Run Keys persistence",
    "T1071.001": "HTTP C2 communication",
    "T1573.001": "Symmetric cryptography for C2",
    "T1041": "Exfiltration over C2 channel"
}

for technique_id, description in attack_mapping.items():
    print(f"[ATT&CK] {technique_id}: {description}")
    # Exportar a reporte
```

---

## 8. Análisis de malware específico

### 8.1 Ransomware

```bash
# Identificar algoritmo de cifrado
strings unpacked.exe | grep -iE "(aes|rsa|chacha20|salsa20)"

# Buscar notas de rescate
find /mnt/infected -name "*.txt" -o -name "*.html" | \
  xargs grep -l "bitcoin\|ransom\|decrypt"

# Analizar extensiones de archivos cifrados
find /mnt/infected -type f | \
  awk -F. '{print $NF}' | sort | uniq -c | sort -rn

# Intentar recuperación con herramientas
# No More Ransom: https://www.nomoreransom.org/
```

### 8.2 Bankers/Infostealers

```bash
# Buscar strings de navegadores
strings malware.exe | grep -i "chrome\|firefox\|edge\|wallet"

# Detectar keylogging
ltrace malware 2>&1 | grep -i "getasynckeystate\|setwindowshook"

# Buscar credenciales objetivo
strings malware.exe | grep -iE "login|password|credential|paypal|bank"
```

### 8.3 APT malware

```bash
# Buscar staging y multi-etapa
tshark -r capture.pcap -Y "http contains \"MZ\"" 

# Analizar beacon intervals (C2 timing)
python3 <<'EOF'
import pyshark
from collections import Counter

cap = pyshark.FileCapture('capture.pcap')
timestamps = []

for packet in cap:
    if hasattr(packet, 'ip') and packet.ip.dst == "C2_IP":
        timestamps.append(float(packet.sniff_timestamp))

# Calcular intervalos
intervals = [timestamps[i+1] - timestamps[i] for i in range(len(timestamps)-1)]
print(f"Average beacon interval: {sum(intervals)/len(intervals):.2f} seconds")
print(f"Interval distribution: {Counter([int(i) for i in intervals])}")
EOF
```

---

## 9. Referencias académicas y recursos

### Libros fundamentales
- Sikorski, M. & Honig, A. (2012). *Practical Malware Analysis*. No Starch Press
- Ligh, M. et al. (2014). *The Art of Memory Forensics*. Wiley
- Eagle, C. & Pochyla, M. (2020). *Ghidra Software Reverse Engineering for Beginners*
- Eilam, E. (2011). *Reversing: Secrets of Reverse Engineering*. Wiley

### Papers académicos
- Szor, P. (2005). *The Art of Computer Virus Research and Defense*
- Yin, H. et al. (2007). "Panorama: Capturing System-wide Information Flow for Malware Detection"
- Rossow, C. et al. (2012). "Prudent Practices for Designing Malware Experiments"
- Moser, A. et al. (2007). "Exploring Multiple Execution Paths for Malware Analysis"

### Frameworks y estándares
- **MITRE ATT&CK**: https://attack.mitre.org/
- **MITRE CAR**: Cyber Analytics Repository
- **OASIS STIX/TAXII**: Threat intelligence sharing
- **MAEC (Malware Attribute Enumeration and Characterization)**

### Herramientas avanzadas
- **Ghidra**: https://ghidra-sre.org/
- **Cuckoo Sandbox**: https://cuckoosandbox.org/
- **CAPE Sandbox**: https://github.com/kevoreilly/CAPEv2
- **ANY.RUN**: https://any.run/ (cloud sandbox)
- **Joe Sandbox**: https://www.joesandbox.com/

### Bases de datos de malware
- **MalwareBazaar**: https://bazaar.abuse.ch/
- **VirusTotal**: https://www.virustotal.com/
- **Hybrid Analysis**: https://www.hybrid-analysis.com/
- **theZoo**: https://github.com/ytisf/theZoo (solo para investigación)

### Cursos y certificaciones
- **GREM (GIAC Reverse Engineering Malware)**: SANS FOR610
- **GCFA (GIAC Certified Forensic Analyst)**: SANS FOR508
- **CREA (Certified Reverse Engineering Analyst)**: Pentester Academy
- **Malware Analysis Bootcamp**: SANS FOR610

---

## 10. Aspectos éticos y legales

### Consideraciones legales
- **Posesión de malware**: Legal si con fines de investigación legítima
- **Distribución**: Ilegal sin contexto apropiado (compartir con colegas en TI es zona gris)
- **Ejecución**: Solo en entornos controlados y aislados
- **Reporting**: Divulgación responsable de vulnerabilidades (CVD)

### Mejores prácticas
1. **Aislamiento total**: Nunca en red de producción
2. **Documentación exhaustiva**: Cadena de custodia digital
3. **Reproducibilidad**: Scripts y metodología documentada
4. **Atribución cautelosa**: No acusar sin evidencia sólida
5. **Compartir inteligencia**: Contribuir a comunidad (hashes, YARA rules)
